%%%%%%%%%%% Csaba start

\sig
ClassicalRewrite( G, gens, type, dim, q, g ): Grp, SeqEnum, MonStgElt, RngIntElt, RngIntElt, GrpElt -> BoolElt, GrpElt
\var Method: MonStgElt : "choose"

\des
$G$ is a classical group of type {\tt type}, which is one of the strings
``SL", ``Sp", ``SU", ``Omega", ``Omega-", or ``Omega+") with dimension 
{\tt dim} over the field $GF( q )$ generated by {\tt gens} 
which satisfy {\tt ClassicalStandardPresentation (type, dim, q )}. 
Further, $g$ must be an element of $Generic (G)$. 

If $g \in G$, then the function 
returns {\tt true} and an SLP for $g$ in {\tt gens};
if $g\not\in G$ then the function searches 
for an SLP {\tt prog} such that {\tt g*Evaluate( prog, gens )^-1} 
centralizes $G$; if it is successful, it returns {\tt false} and 
{\tt prog}. Otherwise the function returns {\tt false, false}.

The function chooses one of the following methods: 

\item[(i)] If $G$ is given in its natural representation and {\tt gens} is
equal to {\tt ClassicalStandardGenerators( type, dim, q )} then Elliot Costi's 
implementation is used. 
\item[(ii)] If (i) is not valid, but $G$ is given in an absolutely 
irreducible representation over the defining characteristic, then
another implementation developed by Csaba Schneider is used. 
This implementation is based on the description given by 
Costi~\cite{CostiThesis}. 
\item[(iii)] If neither of (i) and (ii) is valid, then a ``black-box"
method, independent of the representation of $G$, developed by 
Csaba Schneider is used.  

The optional parameter {\tt Method} can be used to override the
default choice of method. The possible values of {\tt Method} are 
{\tt CharP} and {\tt BB}.

A description of the algorithm used in the defining characteristic case 
appears in~\cite{CostiThesis}; a short description of the black-box algorithm
appears in~\cite{Ambroseetal}.
The package was prepared for distribution by Csaba Schneider.

\beginex{ClassicalRewrite}%\>-------------
\begincode
> gens := [ ExteriorSquare( x ) : x in ClassicalStandardGenerators( "Sp", 6, 25 )]; 
> g := sub< GL( 15, 25 ) | gens >;
> x := Random( g ); v, p := ClassicalRewrite( g, gens, "Sp", 6, 25, x );
> v;
true
> Evaluate( p, gens ) eq x;
true
> v, p := ClassicalRewrite( g, gens, "Sp", 6, 25, x : Method := "BB" );
> v;          
true
> Evaluate( p, gens ) eq x;
true
\endcodex

\sig
ClassicalRewriteNatural( type, tr, g ): MonStgElt, GrpMatElt, GrpMatElt -> BoolElt, GrpElt

\des
The argument {\tt type} must be equal to one of the strings "SL", "Sp", "SU", 
"Omega", "Omega+", "Omega-" and $g$ must be an element of a {\tt 
GL( dim, q )}.

If $g$ is a member of the group generated by 
{\tt ClassicalStandardGenerators( type, dim, q )^tr}
then the function returns {\tt true} and an SLP {\tt prog}
such that {\tt Evaluate( prog, ClassicalStandardGenerators( type, dim, q )^tr )  $= g$. Otherwise the function returns {\tt false, false}. 


This algorithm was developed and implemented by Elliot Costi; 
the package was prepared for distribution by Csaba Schneider.

\beginex{RewriteInClassicalStandardGenerators}%\>-------------
\begincode
> gens := ClassicalStandardGenerators( "SU", 6, 8 );
> g := sub< Parent( gens[1] ) | gens >;
> x := Random( g ); 
> v, p := RewriteInClassicalStandardGenerators( "SU", x );
> v;
true
> Evaluate( p, ClassicalStandardGenerators( "SU", 6, 8 )) eq x;             
true
\endcodex


%%%%%%%%%%%%%% Csaba end
